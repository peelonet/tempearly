#include "interpreter.h"
#include "core/random.h"

namespace tempearly
{
    /**
     * Bool.parse(string) => Bool
     *
     * Attempts to parse string into boolean value. Values "true", "yes" and
     * "on" are parsed as true, while values "false", "no" and "off" are parsed
     * as false. Anything else is considered to be invalid value. Case ignorant.
     *
     * Throws: ValueError - If invalid value is passed as argument.
     */
    TEMPEARLY_NATIVE_METHOD(bool_s_parse)
    {
        String input;

        if (args[0].AsString(interpreter, input))
        {
            input = input.Trim();
            if (input.EqualsIgnoreCase("true")
                || input.EqualsIgnoreCase("yes")
                || input.EqualsIgnoreCase("on"))
            {
                return Value::NewBool(true);
            }
            else if (input.EqualsIgnoreCase("false")
                    || input.EqualsIgnoreCase("no")
                    || input.EqualsIgnoreCase("off"))
            {
                return Value::NewBool(false);
            }
            interpreter->Throw(interpreter->eValueError, "Invalid boolean");
        }

        return Value();
    }

    /**
     * Bool.rand() => Bool
     *
     * Returns boolean value generated by the random number generator included
     * with the interpreter.
     */
    TEMPEARLY_NATIVE_METHOD(bool_s_rand)
    {
        return Value::NewBool(Random::NextBool());
    }

    /**
     * Bool#__hash__() => Int
     *
     * Returns hash code for boolean value, 1231 for true and 1237 for false.
     */
    TEMPEARLY_NATIVE_METHOD(bool_hash)
    {
        return Value::NewInt(args[0].AsBool() ? 1231 : 1237);
    }

    /**
     * Bool#__str__() => String
     *
     * Returns string representation of the boolean object, either "true" or
     * "false".
     */
    TEMPEARLY_NATIVE_METHOD(bool_str)
    {
        return Value::NewString(args[0].AsBool() ? "true" : "false");
    }

    /**
     * Bool#__and__(object) => Bool
     *
     * Bitwise AND. Returns true if the given object evaluates as true and 
     * boolean value itself is true, otherwise false.
     */
    TEMPEARLY_NATIVE_METHOD(bool_and)
    {
        if (args[0].AsBool())
        {
            bool b;

            if (args[1].ToBool(interpreter, b))
            {
                return b ? args[0] : Value::NewBool(false);
            } else {
                return Value();
            }
        }

        return Value::NewBool(false);
    }

    /**
     * Bool#__or__(object) => Bool
     *
     * Bitwise OR. Returns true if boolean value itself is true or the object
     * given as argument evaluates as true, otherwise false.
     */
    TEMPEARLY_NATIVE_METHOD(bool_or)
    {
        if (args[0].AsBool())
        {
            return args[0];
        } else {
            bool b;

            if (args[1].ToBool(interpreter, b))
            {
                return Value::NewBool(b);
            } else {
                return Value();
            }
        }
    }

    /**
     * Bool#__xor__(object) => Bool
     *
     * Bitwise exclusive or. Returns true if the given object evaluates as
     * false and boolean value itself is true, and vice versa.
     */
    TEMPEARLY_NATIVE_METHOD(bool_xor)
    {
        bool b;

        if (args[1].ToBool(interpreter, b))
        {
            if (b)
            {
                return Value::NewBool(!args[0].AsBool());
            } else {
                return args[0];
            }
        } else {
            return Value();
        }
    }

    void init_bool(Interpreter* i)
    {
        i->cBool = i->AddClass("Bool", i->cObject);

        i->cBool->SetAllocator(Class::kNoAlloc);

        i->cBool->AddStaticMethod(i, "parse", 1, bool_s_parse);
        i->cBool->AddStaticMethod(i, "rand", 0, bool_s_rand);

        i->cBool->AddMethod(i, "__hash__", 0, bool_hash);

        i->cBool->AddMethod(i, "__str__", 0, bool_str);

        i->cBool->AddMethod(i, "__and__", 1, bool_and);
        i->cBool->AddMethod(i, "__or__", 1, bool_or);
        i->cBool->AddMethod(i, "__xor__", 1, bool_xor);
    }
}
